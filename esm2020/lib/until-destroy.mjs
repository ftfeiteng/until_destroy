import { Subscription } from 'rxjs';
import { isPipe } from './ivy';
import { getSymbol, completeSubjectOnTheInstance, markAsDecorated, } from './internals';
import 'reflect-metadata';
function unsubscribe(property) {
    if (property instanceof Subscription) {
        property.unsubscribe();
    }
}
function unsubscribeIfPropertyIsArrayLike(property) {
    Array.isArray(property) && property.forEach(unsubscribe);
}
function decorateNgOnDestroy(ngOnDestroy, options) {
    return function () {
        // Invoke the original `ngOnDestroy` if it exists
        ngOnDestroy && ngOnDestroy.call(this);
        // It's important to use `this` instead of caching instance
        // that may lead to memory leaks
        completeSubjectOnTheInstance(this, getSymbol());
        // Check if subscriptions are pushed to some array
        if (options.arrayName) {
            unsubscribeIfPropertyIsArrayLike(this[options.arrayName]);
        }
        // Loop through the properties and find subscriptions
        if (options.checkProperties) {
            for (const property in this) {
                if (options.blackList?.includes(property)) {
                    continue;
                }
                unsubscribe(this[property]);
            }
        }
    };
}
function decorateProviderDirectiveOrComponent(type, options) {
    type.prototype.ngOnDestroy = decorateNgOnDestroy(type.prototype.ngOnDestroy, options);
}
function decoratePipe(type, options) {
    const def = type.Éµpipe;
    def.onDestroy = decorateNgOnDestroy(def.onDestroy, options);
}
export function UntilDestroy(options = {}) {
    return (type) => {
        if (options.className) {
            Reflect.defineMetadata('__className__', options.className, type.prototype);
        }
        if (isPipe(type)) {
            decoratePipe(type, options);
        }
        else {
            decorateProviderDirectiveOrComponent(type, options);
        }
        markAsDecorated(type);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW50aWwtZGVzdHJveS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvdW50aWwtZGVzdHJveS9zcmMvbGliL3VudGlsLWRlc3Ryb3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBS0EsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUVwQyxPQUFPLEVBQVksTUFBTSxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBQ3pDLE9BQU8sRUFDTCxTQUFTLEVBRVQsNEJBQTRCLEVBQzVCLGVBQWUsR0FDaEIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxrQkFBa0IsQ0FBQztBQUUxQixTQUFTLFdBQVcsQ0FBQyxRQUFpQjtJQUNwQyxJQUFJLFFBQVEsWUFBWSxZQUFZLEVBQUU7UUFDcEMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3hCO0FBQ0gsQ0FBQztBQUVELFNBQVMsZ0NBQWdDLENBQUMsUUFBbUI7SUFDM0QsS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzNELENBQUM7QUFFRCxTQUFTLG1CQUFtQixDQUMxQixXQUE0QyxFQUM1QyxPQUE0QjtJQUU1QixPQUFPO1FBQ0wsaURBQWlEO1FBQ2pELFdBQVcsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXRDLDJEQUEyRDtRQUMzRCxnQ0FBZ0M7UUFDaEMsNEJBQTRCLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUM7UUFFaEQsa0RBQWtEO1FBQ2xELElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUNyQixnQ0FBZ0MsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7U0FDM0Q7UUFFRCxxREFBcUQ7UUFDckQsSUFBSSxPQUFPLENBQUMsZUFBZSxFQUFFO1lBQzNCLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFO2dCQUMzQixJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO29CQUN6QyxTQUFTO2lCQUNWO2dCQUVELFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzthQUM3QjtTQUNGO0lBQ0gsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsb0NBQW9DLENBQzNDLElBQTZELEVBQzdELE9BQTRCO0lBRTVCLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3hGLENBQUM7QUFFRCxTQUFTLFlBQVksQ0FBSSxJQUFpQixFQUFFLE9BQTRCO0lBQ3RFLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDdkIsR0FBRyxDQUFDLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQzlELENBQUM7QUFFRCxNQUFNLFVBQVUsWUFBWSxDQUFDLFVBQStCLEVBQUU7SUFDNUQsT0FBTyxDQUFDLElBQVMsRUFBRSxFQUFFO1FBQ25CLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUNyQixPQUFPLENBQUMsY0FBYyxDQUFDLGVBQWUsRUFBRSxPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUM1RTtRQUVELElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2hCLFlBQVksQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDN0I7YUFBTTtZQUNMLG9DQUFvQyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztTQUNyRDtRQUVELGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN4QixDQUFDLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSW5qZWN0YWJsZVR5cGUsXG4gIMm1Q29tcG9uZW50VHlwZSBhcyBDb21wb25lbnRUeXBlLFxuICDJtURpcmVjdGl2ZVR5cGUgYXMgRGlyZWN0aXZlVHlwZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUGlwZVR5cGUsIGlzUGlwZSB9IGZyb20gJy4vaXZ5JztcbmltcG9ydCB7XG4gIGdldFN5bWJvbCxcbiAgVW50aWxEZXN0cm95T3B0aW9ucyxcbiAgY29tcGxldGVTdWJqZWN0T25UaGVJbnN0YW5jZSxcbiAgbWFya0FzRGVjb3JhdGVkLFxufSBmcm9tICcuL2ludGVybmFscyc7XG5pbXBvcnQgJ3JlZmxlY3QtbWV0YWRhdGEnO1xuXG5mdW5jdGlvbiB1bnN1YnNjcmliZShwcm9wZXJ0eTogdW5rbm93bik6IHZvaWQge1xuICBpZiAocHJvcGVydHkgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICBwcm9wZXJ0eS51bnN1YnNjcmliZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3Vic2NyaWJlSWZQcm9wZXJ0eUlzQXJyYXlMaWtlKHByb3BlcnR5OiB1bmtub3duW10pOiB2b2lkIHtcbiAgQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkgJiYgcHJvcGVydHkuZm9yRWFjaCh1bnN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRlTmdPbkRlc3Ryb3koXG4gIG5nT25EZXN0cm95OiAoKCkgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBvcHRpb25zOiBVbnRpbERlc3Ryb3lPcHRpb25zXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzOiBhbnkpIHtcbiAgICAvLyBJbnZva2UgdGhlIG9yaWdpbmFsIGBuZ09uRGVzdHJveWAgaWYgaXQgZXhpc3RzXG4gICAgbmdPbkRlc3Ryb3kgJiYgbmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHVzZSBgdGhpc2AgaW5zdGVhZCBvZiBjYWNoaW5nIGluc3RhbmNlXG4gICAgLy8gdGhhdCBtYXkgbGVhZCB0byBtZW1vcnkgbGVha3NcbiAgICBjb21wbGV0ZVN1YmplY3RPblRoZUluc3RhbmNlKHRoaXMsIGdldFN5bWJvbCgpKTtcblxuICAgIC8vIENoZWNrIGlmIHN1YnNjcmlwdGlvbnMgYXJlIHB1c2hlZCB0byBzb21lIGFycmF5XG4gICAgaWYgKG9wdGlvbnMuYXJyYXlOYW1lKSB7XG4gICAgICB1bnN1YnNjcmliZUlmUHJvcGVydHlJc0FycmF5TGlrZSh0aGlzW29wdGlvbnMuYXJyYXlOYW1lXSk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBwcm9wZXJ0aWVzIGFuZCBmaW5kIHN1YnNjcmlwdGlvbnNcbiAgICBpZiAob3B0aW9ucy5jaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gdGhpcykge1xuICAgICAgICBpZiAob3B0aW9ucy5ibGFja0xpc3Q/LmluY2x1ZGVzKHByb3BlcnR5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdW5zdWJzY3JpYmUodGhpc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVQcm92aWRlckRpcmVjdGl2ZU9yQ29tcG9uZW50PFQ+KFxuICB0eXBlOiBJbmplY3RhYmxlVHlwZTxUPiB8IERpcmVjdGl2ZVR5cGU8VD4gfCBDb21wb25lbnRUeXBlPFQ+LFxuICBvcHRpb25zOiBVbnRpbERlc3Ryb3lPcHRpb25zXG4pOiB2b2lkIHtcbiAgdHlwZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBkZWNvcmF0ZU5nT25EZXN0cm95KHR5cGUucHJvdG90eXBlLm5nT25EZXN0cm95LCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVQaXBlPFQ+KHR5cGU6IFBpcGVUeXBlPFQ+LCBvcHRpb25zOiBVbnRpbERlc3Ryb3lPcHRpb25zKTogdm9pZCB7XG4gIGNvbnN0IGRlZiA9IHR5cGUuybVwaXBlO1xuICBkZWYub25EZXN0cm95ID0gZGVjb3JhdGVOZ09uRGVzdHJveShkZWYub25EZXN0cm95LCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFVudGlsRGVzdHJveShvcHRpb25zOiBVbnRpbERlc3Ryb3lPcHRpb25zID0ge30pOiBDbGFzc0RlY29yYXRvciB7XG4gIHJldHVybiAodHlwZTogYW55KSA9PiB7XG4gICAgaWYgKG9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdfX2NsYXNzTmFtZV9fJywgb3B0aW9ucy5jbGFzc05hbWUsIHR5cGUucHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQaXBlKHR5cGUpKSB7XG4gICAgICBkZWNvcmF0ZVBpcGUodHlwZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY29yYXRlUHJvdmlkZXJEaXJlY3RpdmVPckNvbXBvbmVudCh0eXBlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBtYXJrQXNEZWNvcmF0ZWQodHlwZSk7XG4gIH07XG59XG4iXX0=