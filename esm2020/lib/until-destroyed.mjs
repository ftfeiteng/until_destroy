import { tap } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { setupSubjectUnsubscribedChecker } from './checker';
import { DECORATOR_APPLIED, getSymbol, createSubjectOnTheInstance, completeSubjectOnTheInstance, } from './internals';
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
    const originalDestroy = instance[destroyMethodName];
    if (NG_DEV_MODE && typeof originalDestroy !== 'function') {
        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);
    }
    createSubjectOnTheInstance(instance, symbol);
    instance[destroyMethodName] = function () {
        // eslint-disable-next-line prefer-rest-params
        originalDestroy.apply(this, arguments);
        completeSubjectOnTheInstance(this, symbol);
        // We have to re-assign this property back to the original value.
        // If the `untilDestroyed` operator is called for the same instance
        // multiple times, then we will be able to get the original
        // method again and not the patched one.
        instance[destroyMethodName] = originalDestroy;
    };
}
export function untilDestroyed(instance, destroyMethodName) {
    return (source) => {
        const symbol = getSymbol(destroyMethodName);
        // If `destroyMethodName` is passed then the developer applies
        // this operator to something non-related to Angular DI system
        if (typeof destroyMethodName === 'string') {
            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
        }
        else {
            NG_DEV_MODE && ensureClassIsDecorated(instance);
            createSubjectOnTheInstance(instance, symbol);
        }
        const destroy$ = instance[symbol];
        NG_DEV_MODE && setupSubjectUnsubscribedChecker(instance, destroy$);
        const startTime = Date.now();
        let count = 0;
        console.log("222222");
        return source.pipe(tap({
            next: () => {
                count++;
                console.log("next count: ", count);
            },
            complete: () => {
                console.log("complete count: ", count);
                if (count === 0) {
                    const constructorPrototypeName = Reflect.getMetadata('__className__', instance.constructor.prototype);
                    const endTime = Date.now();
                    console.log(`Source observable is Empty. Constructor: ${constructorPrototypeName ?? instance.constructor.name}. Timespan: ${((endTime - startTime) / 1000).toFixed(2)}s`);
                }
            }
        }), takeUntil(destroy$));
    };
}
function ensureClassIsDecorated(instance) {
    const prototype = Object.getPrototypeOf(instance);
    const missingDecorator = !(DECORATOR_APPLIED in prototype);
    if (missingDecorator) {
        throw new Error('untilDestroyed operator cannot be used inside directives or ' +
            'components or providers that are not decorated with UntilDestroy decorator');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW50aWwtZGVzdHJveWVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy91bnRpbC1kZXN0cm95L3NyYy9saWIvdW50aWwtZGVzdHJveWVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBdUIsR0FBRyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzQyxPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDNUQsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsMEJBQTBCLEVBQzFCLDRCQUE0QixHQUM3QixNQUFNLGFBQWEsQ0FBQztBQU1yQixNQUFNLFdBQVcsR0FBRyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDO0FBRWxFLFNBQVMsa0NBQWtDLENBQ3pDLFFBQWEsRUFDYixpQkFBeUIsRUFDekIsTUFBYztJQUVkLE1BQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRXBELElBQUksV0FBVyxJQUFJLE9BQU8sZUFBZSxLQUFLLFVBQVUsRUFBRTtRQUN4RCxNQUFNLElBQUksS0FBSyxDQUNiLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGtEQUFrRCxpQkFBaUIsRUFBRSxDQUNsRyxDQUFDO0tBQ0g7SUFFRCwwQkFBMEIsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFFN0MsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUc7UUFDNUIsOENBQThDO1FBQzlDLGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZDLDRCQUE0QixDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMzQyxpRUFBaUU7UUFDakUsbUVBQW1FO1FBQ25FLDJEQUEyRDtRQUMzRCx3Q0FBd0M7UUFDeEMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsZUFBZSxDQUFDO0lBQ2hELENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFJLFFBQVcsRUFBRSxpQkFBMkI7SUFDeEUsT0FBTyxDQUFJLE1BQXFCLEVBQUUsRUFBRTtRQUNsQyxNQUFNLE1BQU0sR0FBRyxTQUFTLENBQUksaUJBQWlCLENBQUMsQ0FBQztRQUUvQyw4REFBOEQ7UUFDOUQsOERBQThEO1FBQzlELElBQUksT0FBTyxpQkFBaUIsS0FBSyxRQUFRLEVBQUU7WUFDekMsa0NBQWtDLENBQUMsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3pFO2FBQU07WUFDTCxXQUFXLElBQUksc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDaEQsMEJBQTBCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQzlDO1FBRUQsTUFBTSxRQUFRLEdBQW1CLFFBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDMUQsV0FBVyxJQUFJLCtCQUErQixDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVuRSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDN0IsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN0QixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQ3JCLElBQUksRUFBRSxHQUFHLEVBQUU7Z0JBQ1QsS0FBSyxFQUFFLENBQUM7Z0JBQ1IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDckMsQ0FBQztZQUNELFFBQVEsRUFBRSxHQUFHLEVBQUU7Z0JBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDdkMsSUFBSSxLQUFLLEtBQUssQ0FBQyxFQUFFO29CQUNmLE1BQU0sd0JBQXdCLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FDbEQsZUFBZSxFQUNkLFFBQWdCLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FDeEMsQ0FBQztvQkFDRixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7b0JBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQ1QsNENBQ0Usd0JBQXdCLElBQUssUUFBZ0IsQ0FBQyxXQUFXLENBQUMsSUFDNUQsZUFBZSxDQUFDLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUM1RCxDQUFDO2lCQUNIO1lBQ0gsQ0FBQztTQUNGLENBQUMsRUFBRSxTQUFTLENBQUksUUFBUSxDQUFDLENBQUMsQ0FBQztJQUM5QixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxRQUEyQjtJQUN6RCxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2xELE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixJQUFJLFNBQVMsQ0FBQyxDQUFDO0lBRTNELElBQUksZ0JBQWdCLEVBQUU7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FDYiw4REFBOEQ7WUFDNUQsNEVBQTRFLENBQy9FLENBQUM7S0FDSDtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCB0YXAgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgc2V0dXBTdWJqZWN0VW5zdWJzY3JpYmVkQ2hlY2tlciB9IGZyb20gJy4vY2hlY2tlcic7XG5pbXBvcnQge1xuICBERUNPUkFUT1JfQVBQTElFRCxcbiAgZ2V0U3ltYm9sLFxuICBjcmVhdGVTdWJqZWN0T25UaGVJbnN0YW5jZSxcbiAgY29tcGxldGVTdWJqZWN0T25UaGVJbnN0YW5jZSxcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuXG4vLyBUaGlzIHdpbGwgYmUgcHJvdmlkZWQgdGhyb3VnaCBUZXJzZXIgZ2xvYmFsIGRlZmluaXRpb25zIGJ5IEFuZ3VsYXIgQ0xJLiBUaGlzIHdpbGxcbi8vIGhlbHAgdG8gdHJlZS1zaGFrZSBhd2F5IHRoZSBjb2RlIHVubmVlZGVkIGZvciBwcm9kdWN0aW9uIGJ1bmRsZXMuXG5kZWNsYXJlIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcblxuY29uc3QgTkdfREVWX01PREUgPSB0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGU7XG5cbmZ1bmN0aW9uIG92ZXJyaWRlTm9uRGlyZWN0aXZlSW5zdGFuY2VNZXRob2QoXG4gIGluc3RhbmNlOiBhbnksXG4gIGRlc3Ryb3lNZXRob2ROYW1lOiBzdHJpbmcsXG4gIHN5bWJvbDogc3ltYm9sXG4pOiB2b2lkIHtcbiAgY29uc3Qgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2VbZGVzdHJveU1ldGhvZE5hbWVdO1xuXG4gIGlmIChOR19ERVZfTU9ERSAmJiB0eXBlb2Ygb3JpZ2luYWxEZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCR7aW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0gaXMgdXNpbmcgdW50aWxEZXN0cm95ZWQgYnV0IGRvZXNuJ3QgaW1wbGVtZW50ICR7ZGVzdHJveU1ldGhvZE5hbWV9YFxuICAgICk7XG4gIH1cblxuICBjcmVhdGVTdWJqZWN0T25UaGVJbnN0YW5jZShpbnN0YW5jZSwgc3ltYm9sKTtcblxuICBpbnN0YW5jZVtkZXN0cm95TWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIG9yaWdpbmFsRGVzdHJveS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGNvbXBsZXRlU3ViamVjdE9uVGhlSW5zdGFuY2UodGhpcywgc3ltYm9sKTtcbiAgICAvLyBXZSBoYXZlIHRvIHJlLWFzc2lnbiB0aGlzIHByb3BlcnR5IGJhY2sgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgIC8vIElmIHRoZSBgdW50aWxEZXN0cm95ZWRgIG9wZXJhdG9yIGlzIGNhbGxlZCBmb3IgdGhlIHNhbWUgaW5zdGFuY2VcbiAgICAvLyBtdWx0aXBsZSB0aW1lcywgdGhlbiB3ZSB3aWxsIGJlIGFibGUgdG8gZ2V0IHRoZSBvcmlnaW5hbFxuICAgIC8vIG1ldGhvZCBhZ2FpbiBhbmQgbm90IHRoZSBwYXRjaGVkIG9uZS5cbiAgICBpbnN0YW5jZVtkZXN0cm95TWV0aG9kTmFtZV0gPSBvcmlnaW5hbERlc3Ryb3k7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnRpbERlc3Ryb3llZDxUPihpbnN0YW5jZTogVCwgZGVzdHJveU1ldGhvZE5hbWU/OiBrZXlvZiBUKSB7XG4gIHJldHVybiA8VT4oc291cmNlOiBPYnNlcnZhYmxlPFU+KSA9PiB7XG4gICAgY29uc3Qgc3ltYm9sID0gZ2V0U3ltYm9sPFQ+KGRlc3Ryb3lNZXRob2ROYW1lKTtcblxuICAgIC8vIElmIGBkZXN0cm95TWV0aG9kTmFtZWAgaXMgcGFzc2VkIHRoZW4gdGhlIGRldmVsb3BlciBhcHBsaWVzXG4gICAgLy8gdGhpcyBvcGVyYXRvciB0byBzb21ldGhpbmcgbm9uLXJlbGF0ZWQgdG8gQW5ndWxhciBESSBzeXN0ZW1cbiAgICBpZiAodHlwZW9mIGRlc3Ryb3lNZXRob2ROYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgb3ZlcnJpZGVOb25EaXJlY3RpdmVJbnN0YW5jZU1ldGhvZChpbnN0YW5jZSwgZGVzdHJveU1ldGhvZE5hbWUsIHN5bWJvbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE5HX0RFVl9NT0RFICYmIGVuc3VyZUNsYXNzSXNEZWNvcmF0ZWQoaW5zdGFuY2UpO1xuICAgICAgY3JlYXRlU3ViamVjdE9uVGhlSW5zdGFuY2UoaW5zdGFuY2UsIHN5bWJvbCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVzdHJveSQ6IFN1YmplY3Q8dm9pZD4gPSAoaW5zdGFuY2UgYXMgYW55KVtzeW1ib2xdO1xuICAgIE5HX0RFVl9NT0RFICYmIHNldHVwU3ViamVjdFVuc3Vic2NyaWJlZENoZWNrZXIoaW5zdGFuY2UsIGRlc3Ryb3kkKTtcblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zb2xlLmxvZyhcIjIyMjIyMlwiKTtcbiAgICByZXR1cm4gc291cmNlLnBpcGUodGFwKHtcbiAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgY29uc29sZS5sb2coXCJuZXh0IGNvdW50OiBcIiwgY291bnQpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiY29tcGxldGUgY291bnQ6IFwiLCBjb3VudCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yUHJvdG90eXBlTmFtZSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXG4gICAgICAgICAgICAnX19jbGFzc05hbWVfXycsXG4gICAgICAgICAgICAoaW5zdGFuY2UgYXMgYW55KS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYFNvdXJjZSBvYnNlcnZhYmxlIGlzIEVtcHR5LiBDb25zdHJ1Y3RvcjogJHtcbiAgICAgICAgICAgICAgY29uc3RydWN0b3JQcm90b3R5cGVOYW1lID8/IChpbnN0YW5jZSBhcyBhbnkpLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgIH0uIFRpbWVzcGFuOiAkeygoZW5kVGltZSAtIHN0YXJ0VGltZSkgLyAxMDAwKS50b0ZpeGVkKDIpfXNgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCB0YWtlVW50aWw8VT4oZGVzdHJveSQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlQ2xhc3NJc0RlY29yYXRlZChpbnN0YW5jZTogSW5zdGFuY2VUeXBlPGFueT4pOiBuZXZlciB8IHZvaWQge1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpO1xuICBjb25zdCBtaXNzaW5nRGVjb3JhdG9yID0gIShERUNPUkFUT1JfQVBQTElFRCBpbiBwcm90b3R5cGUpO1xuXG4gIGlmIChtaXNzaW5nRGVjb3JhdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3VudGlsRGVzdHJveWVkIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBkaXJlY3RpdmVzIG9yICcgK1xuICAgICAgICAnY29tcG9uZW50cyBvciBwcm92aWRlcnMgdGhhdCBhcmUgbm90IGRlY29yYXRlZCB3aXRoIFVudGlsRGVzdHJveSBkZWNvcmF0b3InXG4gICAgKTtcbiAgfVxufVxuIl19