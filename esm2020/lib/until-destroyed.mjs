import { catchError, isEmpty, of } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { setupSubjectUnsubscribedChecker } from './checker';
import { DECORATOR_APPLIED, getSymbol, createSubjectOnTheInstance, completeSubjectOnTheInstance, } from './internals';
import 'reflect-metadata';
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
function overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol) {
    const originalDestroy = instance[destroyMethodName];
    if (NG_DEV_MODE && typeof originalDestroy !== 'function') {
        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${destroyMethodName}`);
    }
    createSubjectOnTheInstance(instance, symbol);
    instance[destroyMethodName] = function () {
        // eslint-disable-next-line prefer-rest-params
        originalDestroy.apply(this, arguments);
        completeSubjectOnTheInstance(this, symbol);
        // We have to re-assign this property back to the original value.
        // If the `untilDestroyed` operator is called for the same instance
        // multiple times, then we will be able to get the original
        // method again and not the patched one.
        instance[destroyMethodName] = originalDestroy;
    };
}
export function untilDestroyed(instance, destroyMethodName) {
    return (source) => {
        const symbol = getSymbol(destroyMethodName);
        // If `destroyMethodName` is passed then the developer applies
        // this operator to something non-related to Angular DI system
        if (typeof destroyMethodName === 'string') {
            overrideNonDirectiveInstanceMethod(instance, destroyMethodName, symbol);
        }
        else {
            NG_DEV_MODE && ensureClassIsDecorated(instance);
            createSubjectOnTheInstance(instance, symbol);
        }
        const destroy$ = instance[symbol];
        NG_DEV_MODE && setupSubjectUnsubscribedChecker(instance, destroy$);
        const startTime = Date.now();
        const sharedObservable = source.pipe(takeUntil(destroy$));
        console.log("Testing version");
        sharedObservable
            .pipe(isEmpty(), catchError(_ => of(false)))
            .subscribe(empty => {
            if (empty) {
                const constructorPrototypeName = Reflect.getMetadata('__className__', instance.constructor.prototype);
                const endTime = Date.now();
                console.log(`Source observable is Empty. Constructor: ${constructorPrototypeName ?? instance.constructor.name}. Timespan: ${((endTime - startTime) / 1000).toFixed(2)}s`);
            }
        });
        return sharedObservable;
    };
}
function ensureClassIsDecorated(instance) {
    const prototype = Object.getPrototypeOf(instance);
    const missingDecorator = !(DECORATOR_APPLIED in prototype);
    if (missingDecorator) {
        throw new Error('untilDestroyed operator cannot be used inside directives or ' +
            'components or providers that are not decorated with UntilDestroy decorator');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW50aWwtZGVzdHJveWVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy91bnRpbC1kZXN0cm95L3NyYy9saWIvdW50aWwtZGVzdHJveWVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFjLEVBQUUsRUFBVyxNQUFNLE1BQU0sQ0FBQztBQUNwRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQzVELE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULDBCQUEwQixFQUMxQiw0QkFBNEIsR0FDN0IsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxrQkFBa0IsQ0FBQztBQU0xQixNQUFNLFdBQVcsR0FBRyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDO0FBRWxFLFNBQVMsa0NBQWtDLENBQ3pDLFFBQWEsRUFDYixpQkFBeUIsRUFDekIsTUFBYztJQUVkLE1BQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRXBELElBQUksV0FBVyxJQUFJLE9BQU8sZUFBZSxLQUFLLFVBQVUsRUFBRTtRQUN4RCxNQUFNLElBQUksS0FBSyxDQUNiLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGtEQUFrRCxpQkFBaUIsRUFBRSxDQUNsRyxDQUFDO0tBQ0g7SUFFRCwwQkFBMEIsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFFN0MsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUc7UUFDNUIsOENBQThDO1FBQzlDLGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZDLDRCQUE0QixDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMzQyxpRUFBaUU7UUFDakUsbUVBQW1FO1FBQ25FLDJEQUEyRDtRQUMzRCx3Q0FBd0M7UUFDeEMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsZUFBZSxDQUFDO0lBQ2hELENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFJLFFBQVcsRUFBRSxpQkFBMkI7SUFDeEUsT0FBTyxDQUFJLE1BQXFCLEVBQUUsRUFBRTtRQUNsQyxNQUFNLE1BQU0sR0FBRyxTQUFTLENBQUksaUJBQWlCLENBQUMsQ0FBQztRQUUvQyw4REFBOEQ7UUFDOUQsOERBQThEO1FBQzlELElBQUksT0FBTyxpQkFBaUIsS0FBSyxRQUFRLEVBQUU7WUFDekMsa0NBQWtDLENBQUMsUUFBUSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3pFO2FBQU07WUFDTCxXQUFXLElBQUksc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDaEQsMEJBQTBCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQzlDO1FBRUQsTUFBTSxRQUFRLEdBQW1CLFFBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDMUQsV0FBVyxJQUFJLCtCQUErQixDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUVuRSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDN0IsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBSSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzdELE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUMvQixnQkFBZ0I7YUFDYixJQUFJLENBQ0gsT0FBTyxFQUFFLEVBQ1QsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQzNCO2FBQ0EsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2pCLElBQUksS0FBSyxFQUFFO2dCQUNULE1BQU0sd0JBQXdCLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FDbEQsZUFBZSxFQUNkLFFBQWdCLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FDeEMsQ0FBQztnQkFDRixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQ1QsNENBQ0Usd0JBQXdCLElBQUssUUFBZ0IsQ0FBQyxXQUFXLENBQUMsSUFDNUQsZUFBZSxDQUFDLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUM1RCxDQUFDO2FBQ0g7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVMLE9BQU8sZ0JBQWdCLENBQUM7SUFDMUIsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsc0JBQXNCLENBQUMsUUFBMkI7SUFDekQsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsRCxNQUFNLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxpQkFBaUIsSUFBSSxTQUFTLENBQUMsQ0FBQztJQUUzRCxJQUFJLGdCQUFnQixFQUFFO1FBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQ2IsOERBQThEO1lBQzVELDRFQUE0RSxDQUMvRSxDQUFDO0tBQ0g7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2F0Y2hFcnJvciwgaXNFbXB0eSwgT2JzZXJ2YWJsZSwgb2YsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgc2V0dXBTdWJqZWN0VW5zdWJzY3JpYmVkQ2hlY2tlciB9IGZyb20gJy4vY2hlY2tlcic7XG5pbXBvcnQge1xuICBERUNPUkFUT1JfQVBQTElFRCxcbiAgZ2V0U3ltYm9sLFxuICBjcmVhdGVTdWJqZWN0T25UaGVJbnN0YW5jZSxcbiAgY29tcGxldGVTdWJqZWN0T25UaGVJbnN0YW5jZSxcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuaW1wb3J0ICdyZWZsZWN0LW1ldGFkYXRhJztcblxuLy8gVGhpcyB3aWxsIGJlIHByb3ZpZGVkIHRocm91Z2ggVGVyc2VyIGdsb2JhbCBkZWZpbml0aW9ucyBieSBBbmd1bGFyIENMSS4gVGhpcyB3aWxsXG4vLyBoZWxwIHRvIHRyZWUtc2hha2UgYXdheSB0aGUgY29kZSB1bm5lZWRlZCBmb3IgcHJvZHVjdGlvbiBidW5kbGVzLlxuZGVjbGFyZSBjb25zdCBuZ0Rldk1vZGU6IGJvb2xlYW47XG5cbmNvbnN0IE5HX0RFVl9NT0RFID0gdHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlO1xuXG5mdW5jdGlvbiBvdmVycmlkZU5vbkRpcmVjdGl2ZUluc3RhbmNlTWV0aG9kKFxuICBpbnN0YW5jZTogYW55LFxuICBkZXN0cm95TWV0aG9kTmFtZTogc3RyaW5nLFxuICBzeW1ib2w6IHN5bWJvbFxuKTogdm9pZCB7XG4gIGNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IGluc3RhbmNlW2Rlc3Ryb3lNZXRob2ROYW1lXTtcblxuICBpZiAoTkdfREVWX01PREUgJiYgdHlwZW9mIG9yaWdpbmFsRGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGAke2luc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWV9IGlzIHVzaW5nIHVudGlsRGVzdHJveWVkIGJ1dCBkb2Vzbid0IGltcGxlbWVudCAke2Rlc3Ryb3lNZXRob2ROYW1lfWBcbiAgICApO1xuICB9XG5cbiAgY3JlYXRlU3ViamVjdE9uVGhlSW5zdGFuY2UoaW5zdGFuY2UsIHN5bWJvbCk7XG5cbiAgaW5zdGFuY2VbZGVzdHJveU1ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICBvcmlnaW5hbERlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBjb21wbGV0ZVN1YmplY3RPblRoZUluc3RhbmNlKHRoaXMsIHN5bWJvbCk7XG4gICAgLy8gV2UgaGF2ZSB0byByZS1hc3NpZ24gdGhpcyBwcm9wZXJ0eSBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAvLyBJZiB0aGUgYHVudGlsRGVzdHJveWVkYCBvcGVyYXRvciBpcyBjYWxsZWQgZm9yIHRoZSBzYW1lIGluc3RhbmNlXG4gICAgLy8gbXVsdGlwbGUgdGltZXMsIHRoZW4gd2Ugd2lsbCBiZSBhYmxlIHRvIGdldCB0aGUgb3JpZ2luYWxcbiAgICAvLyBtZXRob2QgYWdhaW4gYW5kIG5vdCB0aGUgcGF0Y2hlZCBvbmUuXG4gICAgaW5zdGFuY2VbZGVzdHJveU1ldGhvZE5hbWVdID0gb3JpZ2luYWxEZXN0cm95O1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW50aWxEZXN0cm95ZWQ8VD4oaW5zdGFuY2U6IFQsIGRlc3Ryb3lNZXRob2ROYW1lPzoga2V5b2YgVCkge1xuICByZXR1cm4gPFU+KHNvdXJjZTogT2JzZXJ2YWJsZTxVPikgPT4ge1xuICAgIGNvbnN0IHN5bWJvbCA9IGdldFN5bWJvbDxUPihkZXN0cm95TWV0aG9kTmFtZSk7XG5cbiAgICAvLyBJZiBgZGVzdHJveU1ldGhvZE5hbWVgIGlzIHBhc3NlZCB0aGVuIHRoZSBkZXZlbG9wZXIgYXBwbGllc1xuICAgIC8vIHRoaXMgb3BlcmF0b3IgdG8gc29tZXRoaW5nIG5vbi1yZWxhdGVkIHRvIEFuZ3VsYXIgREkgc3lzdGVtXG4gICAgaWYgKHR5cGVvZiBkZXN0cm95TWV0aG9kTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG92ZXJyaWRlTm9uRGlyZWN0aXZlSW5zdGFuY2VNZXRob2QoaW5zdGFuY2UsIGRlc3Ryb3lNZXRob2ROYW1lLCBzeW1ib2wpO1xuICAgIH0gZWxzZSB7XG4gICAgICBOR19ERVZfTU9ERSAmJiBlbnN1cmVDbGFzc0lzRGVjb3JhdGVkKGluc3RhbmNlKTtcbiAgICAgIGNyZWF0ZVN1YmplY3RPblRoZUluc3RhbmNlKGluc3RhbmNlLCBzeW1ib2wpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc3Ryb3kkOiBTdWJqZWN0PHZvaWQ+ID0gKGluc3RhbmNlIGFzIGFueSlbc3ltYm9sXTtcbiAgICBOR19ERVZfTU9ERSAmJiBzZXR1cFN1YmplY3RVbnN1YnNjcmliZWRDaGVja2VyKGluc3RhbmNlLCBkZXN0cm95JCk7XG5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHNoYXJlZE9ic2VydmFibGUgPSBzb3VyY2UucGlwZSh0YWtlVW50aWw8VT4oZGVzdHJveSQpKTtcbiAgICBjb25zb2xlLmxvZyhcIlRlc3RpbmcgdmVyc2lvblwiKTtcbiAgICBzaGFyZWRPYnNlcnZhYmxlXG4gICAgICAucGlwZShcbiAgICAgICAgaXNFbXB0eSgpLFxuICAgICAgICBjYXRjaEVycm9yKF8gPT4gb2YoZmFsc2UpKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShlbXB0eSA9PiB7XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yUHJvdG90eXBlTmFtZSA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXG4gICAgICAgICAgICAnX19jbGFzc05hbWVfXycsXG4gICAgICAgICAgICAoaW5zdGFuY2UgYXMgYW55KS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYFNvdXJjZSBvYnNlcnZhYmxlIGlzIEVtcHR5LiBDb25zdHJ1Y3RvcjogJHtcbiAgICAgICAgICAgICAgY29uc3RydWN0b3JQcm90b3R5cGVOYW1lID8/IChpbnN0YW5jZSBhcyBhbnkpLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgICAgIH0uIFRpbWVzcGFuOiAkeygoZW5kVGltZSAtIHN0YXJ0VGltZSkgLyAxMDAwKS50b0ZpeGVkKDIpfXNgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICByZXR1cm4gc2hhcmVkT2JzZXJ2YWJsZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlQ2xhc3NJc0RlY29yYXRlZChpbnN0YW5jZTogSW5zdGFuY2VUeXBlPGFueT4pOiBuZXZlciB8IHZvaWQge1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpO1xuICBjb25zdCBtaXNzaW5nRGVjb3JhdG9yID0gIShERUNPUkFUT1JfQVBQTElFRCBpbiBwcm90b3R5cGUpO1xuXG4gIGlmIChtaXNzaW5nRGVjb3JhdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ3VudGlsRGVzdHJveWVkIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBkaXJlY3RpdmVzIG9yICcgK1xuICAgICAgICAnY29tcG9uZW50cyBvciBwcm92aWRlcnMgdGhhdCBhcmUgbm90IGRlY29yYXRlZCB3aXRoIFVudGlsRGVzdHJveSBkZWNvcmF0b3InXG4gICAgKTtcbiAgfVxufVxuIl19